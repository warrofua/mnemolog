<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conversation — Mnemolog</title>
    <meta property="og:title" content="Conversation — Mnemolog">
    <meta property="og:description" content="A shared conversation on Mnemolog.">
    <meta property="og:type" content="article">
    <meta property="og:image" content="https://mnemolog.com/assets/mnemolog_og.png">
    <meta property="twitter:card" content="summary">
    <meta property="twitter:image" content="https://mnemolog.com/assets/mnemolog_og.png">
    <link rel="icon" href="/assets/mnemolog-fav-icon.svg" type="image/svg+xml">
    <link rel="icon" href="/assets/mnemolog_og.png" type="image/png" sizes="180x180">
    <link rel="apple-touch-icon" href="/assets/mnemolog_og.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,500;0,600;1,400&family=DM+Sans:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/assets/styles.css">
    <style>
        :root {
            --human-bg: #FDF9F3;
            --assistant-bg: #FFFFFF;
        }

        :root[data-theme="dark"],
        body.dark-mode {
            --human-bg: #312b24;
            --assistant-bg: #2a251f;
        }

        nav {
            background: var(--bg);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
        }

        .loading {
            text-align: center;
            padding: 4rem 2rem;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .error-state {
            text-align: center;
            padding: 4rem 2rem;
        }

        .error-state h1 {
            font-family: 'Cormorant Garamond', serif;
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .error-state p {
            color: var(--text-secondary);
            margin-bottom: 1.5rem;
        }

        .conversation-header {
            margin-bottom: 2rem;
            padding-bottom: 2rem;
            border-bottom: 1px solid var(--border);
        }

        .conversation-meta {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .platform-badge {
            background: var(--bg-warm);
            padding: 0.3rem 0.75rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .model-badge, .attrib-badge {
            background: rgba(184, 134, 11, 0.12);
            color: var(--accent);
            padding: 0.25rem 0.6rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .date, .view-count {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .view-count {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
        }

        .conversation-header h1 {
            font-family: 'Cormorant Garamond', serif;
            font-size: 2.5rem;
            font-weight: 400;
            line-height: 1.2;
            margin-bottom: 0.75rem;
        }

        .conversation-description {
            color: var(--text-secondary);
            font-size: 1.05rem;
        }

        .tags {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        .tag {
            background: rgba(184, 134, 11, 0.1);
            color: var(--accent);
            padding: 0.25rem 0.6rem;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .author-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
        }

        .continue-actions {
            margin-top: 1.25rem;
            display: flex;
            gap: 0.75rem;
            align-items: center;
            flex-wrap: wrap;
            justify-content: flex-start;
            position: relative;
        }

        .fork-btn {
            position: absolute;
            top: 8px;
            right: 10px;
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 4px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .fork-btn svg {
            width: 26px;
            height: 26px;
        }
        .fork-btn:hover {
            color: var(--accent);
        }

        .copy-md-btn {
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text);
        }
        .copy-md-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .author-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--bg-warm);
            object-fit: cover;
        }

        .author-name { font-weight: 500; }
        .author-label { font-size: 0.8rem; color: var(--text-secondary); }

        .bookmark-btn {
            margin-left: auto;
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.45rem 0.7rem;
            border-radius: 999px;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text);
            cursor: pointer;
            transition: all 0.2s;
        }
        .bookmark-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }
        .bookmark-btn .icon {
            width: 16px;
            height: 16px;
        }
        .bookmark-btn.saved {
            background: var(--accent);
            border-color: var(--accent);
            color: #fff;
        }
        .bookmark-btn.saved:hover {
            background: var(--accent);
            color: #fff;
        }

        /* Continue modal */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        .modal-backdrop.show { display: flex; }
        .modal {
            background: var(--bg);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 1.25rem;
            width: min(420px, 92vw);
            box-shadow: 0 14px 40px rgba(0,0,0,0.25);
        }
        .modal h3 {
            margin: 0 0 0.5rem;
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.5rem;
        }
        .modal label {
            display: block;
            margin: 0.5rem 0 0.25rem;
            font-weight: 600;
            color: var(--text);
        }
        .modal select,
        .modal textarea {
            width: 100%;
            padding: 0.65rem 0.75rem;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text);
            font-family: 'DM Sans', sans-serif;
        }
        .modal textarea { min-height: 90px; }
        .modal-actions {
            margin-top: 1rem;
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
        }
        .modal .btn {
            border-radius: 8px;
        }
        .small-text {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        .nemo-mark {
            font-family: 'Cormorant Garamond', serif;
            font-weight: 700;
            color: #2C2A26;
            text-transform: lowercase;
            font-size: 1.2em;
            position: relative;
            top: -1px;
        }

        .title-font {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.25em;
        }

        .tooltip-icon {
            position: relative;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text);
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        .tooltip-icon svg { width: 14px; height: 14px; }
        .tooltip-text {
            position: absolute;
            top: 115%;
            right: 0;
            background: var(--bg);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.6rem 0.75rem;
            font-size: 0.9rem;
            min-width: 220px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.15s ease;
            z-index: 5;
        }
        .tooltip-icon:focus .tooltip-text,
        .tooltip-icon:hover .tooltip-text,
        .tooltip-icon.active .tooltip-text {
            opacity: 1;
            pointer-events: auto;
        }

        .messages {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .message {
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid var(--border);
            position: relative;
        }

        .message.loading {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            background: var(--bg-warm);
            border-style: dashed;
        }

        .spinner-inline {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .message.meta {
            background: var(--bg-warm);
            border-style: dashed;
            font-family: 'Cormorant Garamond', serif;
            color: var(--text);
        }

        .message.meta .meta-title {
            font-size: 1.05rem;
            font-weight: 600;
            margin-bottom: 0.35rem;
        }

        .message.meta .meta-prompt {
            font-family: 'DM Sans', sans-serif;
            font-size: 0.95rem;
            color: var(--text-secondary);
        }

        .message.human {
            background: var(--human-bg);
            border-left: 3px solid var(--accent);
        }

        .message.assistant {
            background: var(--assistant-bg);
            border-left: 3px solid var(--thread);
        }

        .message-role {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.75rem;
            font-weight: 500;
        }

        .message.human .message-role { color: var(--accent); }
        .message.assistant .message-role { color: var(--text-secondary); }

        .message-content {
            font-size: 0.95rem;
            line-height: 1.8;
            white-space: pre-wrap;
        }

        .message-content p { margin-bottom: 1rem; }
        .message-content p:last-child { margin-bottom: 0; }

        .message-content code {
            background: var(--bg-warm);
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            font-size: 0.9em;
        }

        .message-content pre {
            background: var(--bg-warm);
            color: var(--text);
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
            margin: 1rem 0;
        }

        .message-content pre code {
            background: none;
            padding: 0;
            color: inherit;
        }

        .continuations-panel {
            margin-top: 2rem;
            padding: 1rem;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--bg-warm);
        }
        .continuations-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        .continuations-list {
            margin-top: 0.75rem;
            display: none;
            flex-direction: column;
            gap: 0.5rem;
        }
        .continuations-list.show { display: flex; }
        .hidden-continuation { display: none; }
        @media (min-width: 1200px) {
            .continuations-panel.top-panel {
                position: absolute;
                top: 0;
                width: 320px;
                left: calc(100% + 24px);
                margin-top: 0;
            }
        }
        .continuation-item {
            padding: 0.75rem;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--bg);
        }
        .continuation-item h4 {
            margin: 0 0 0.25rem;
            font-size: 1rem;
        }
        .continuation-meta {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        .btn-compact {
            padding: 0.35rem 0.6rem;
            font-size: 0.85rem;
        }

        /* Lineage graph */
        .lineage-container {
            margin-top: 1.5rem;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--bg-warm);
        }
        .lineage-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            padding: 0.85rem 1rem;
        }
        .lineage-canvas {
            width: 100%;
            height: 360px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--bg);
            position: relative;
            overflow: hidden;
            margin: 0 1rem 1rem;
        }
        .lineage-legend {
            position: absolute;
            right: 12px;
            bottom: 12px;
            background: rgba(0,0,0,0.6);
            color: #fff;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            font-size: 0.85rem;
            display: flex;
            gap: 0.6rem;
            align-items: center;
        }
        .lineage-legend span {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }
        .lineage-toolbar {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .lineage-tooltip {
            position: absolute;
            pointer-events: none;
            background: rgba(0,0,0,0.75);
            color: #fff;
            padding: 0.4rem 0.6rem;
            border-radius: 4px;
            font-size: 0.85rem;
            display: none;
            z-index: 5;
            max-width: 240px;
        }

        .share-bar {
            margin-top: 3rem;
            padding: 1.5rem;
            background: var(--bg-warm);
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .chat-composer {
            margin-top: 2rem;
            padding: 1.25rem;
            border: 1px solid var(--border);
            border-radius: 10px;
            background: var(--bg-warm);
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .chat-composer textarea {
            width: 100%;
            min-height: 90px;
            padding: 0.75rem;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text);
            font-family: 'DM Sans', sans-serif;
        }
        .chat-actions {
            display: flex;
            gap: 0.75rem;
            align-items: center;
            justify-content: flex-end;
        }
        .chat-error {
            font-size: 0.9rem;
            color: var(--warning);
            display: none;
        }
        .chat-loading {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: none;
        }
        .chat-waiting {
            display: none;
            align-items: center;
            gap: 0.5rem;
            color: var(--text-secondary);
            font-size: 0.95rem;
        }
        .chat-waiting .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent);
            animation: pulse 1s ease-in-out infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.2); opacity: 0.4; }
            100% { transform: scale(1); opacity: 0.8; }
        }

        .share-bar p {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .share-actions {
            display: flex;
            gap: 0.75rem;
        }

        .copy-btn {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .copy-btn.copied {
            background: #2E7D4A;
            border-color: #2E7D4A;
            color: white;
        }

        footer {
            margin-top: 4rem;
            padding: 2rem;
            border-top: 1px solid var(--border);
            text-align: center;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        footer a {
            color: var(--text-secondary);
            text-decoration: none;
            margin: 0 1rem;
        }

        footer a:hover { color: var(--text); }

        @media (max-width: 600px) {
            nav { padding: 1rem 1.5rem; }
            .container { padding: 1.5rem; }
            .conversation-header h1 { font-size: 1.75rem; }
            .share-bar { flex-direction: column; text-align: center; }
            #continue-btn { width: 80%; }
            .hero-actions,
            .hero-cta,
            #continue-btn {
                justify-content: center;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div id="site-header"></div>

    <div class="container">
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Loading conversation...</p>
        </div>

        <div class="error-state" id="error" style="display: none;">
            <h1>Conversation not found</h1>
            <p>This conversation may have been removed or made private.</p>
            <a href="/" class="btn btn-primary">Back to Home</a>
        </div>

        <article id="conversation" style="display: none;">
            <header class="conversation-header">
                <div class="conversation-meta">
                    <span class="platform-badge" id="platform"></span>
                    <span class="model-badge" id="model"></span>
                    <span class="attrib-badge" id="attrib"></span>
                    <span class="model-badge" id="lineage-badge" style="display:none;">Continuation</span>
                    <span class="date" id="date"></span>
                    <span class="view-count">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                            <circle cx="12" cy="12" r="3"/>
                        </svg>
                        <span id="views">0</span>
                    </span>
                    <a id="visit-original" class="btn btn-secondary btn-compact" style="display:none;">Visit original</a>
                </div>
                <h1 id="title"></h1>
                <p class="conversation-description" id="description"></p>
                <div class="tags" id="tags"></div>
                <div class="author-info" id="author-info" style="display: none;">
                    <img class="author-avatar" id="author-avatar" src="" alt="">
                    <div>
                        <div class="author-name" id="author-name"></div>
                        <div class="author-label">Shared this conversation</div>
                    </div>
                    <button class="bookmark-btn" id="bookmark-btn" title="Save bookmark">
                        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M6 4h12a2 2 0 0 1 2 2v15l-8-4-8 4V6a2 2 0 0 1 2-2z"/>
                        </svg>
                        <span id="bookmark-label">Save</span>
                    </button>
                </div>
                <div style="margin-top: 1rem;">
                    <a id="edit-btn" href="#" class="btn btn-secondary" style="display:none;">Edit / Re-parse</a>
                </div>
            <div class="continue-actions">
                <button class="btn btn-primary title-font" id="continue-btn"><em>Continue</em> <em>with</em> <span class="nemo-mark">Nemo</span></button>
                <button class="tooltip-icon" id="continue-tooltip" aria-label="More info" type="button">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <line x1="12" y1="8" x2="12" y2="8"/>
                        <line x1="12" y1="10" x2="12" y2="16"/>
                    </svg>
                    <span class="tooltip-text">Click to continue a version of this AI chat with Nemo (DeepSeek v3.2).</span>
                </button>
                <button class="btn copy-md-btn" id="copy-md-btn" type="button">Continue on another platform</button>
            </div>
        </header>

        <div class="continuations-panel top-panel" id="continuations-panel-top" style="display:none;">
            <div class="continuations-header" id="continuations-toggle-top">
                <span style="font-weight:600;">Continuations</span>
                <span id="continuations-count-top"></span>
            </div>
            <div class="continuations-list" id="continuations-list-top"></div>
        </div>

        <div class="lineage-container">
            <div class="lineage-header" id="lineage-toggle">
                <h3 style="margin:0;">Lineage Graph</h3>
                <div class="lineage-toolbar">
                    <button class="btn btn-secondary btn-compact" id="lineage-refresh" type="button">Refresh</button>
                    <button class="btn btn-secondary btn-compact" id="lineage-collapse" type="button">Collapse</button>
                </div>
            </div>
            <div class="lineage-canvas" id="lineage-canvas">
                <div class="lineage-tooltip" id="lineage-tooltip"></div>
                <div class="lineage-legend">
                    <span><span class="legend-dot" style="background:#b8860b;"></span>Root / Current</span>
                    <span><span class="legend-dot" style="background:#2e7d4a;"></span>Continuation</span>
                    <span><span class="legend-dot" style="background:#8a5adf;"></span>Fork</span>
                </div>
            </div>
        </div>

            <div class="messages" id="messages"></div>

            <div class="chat-composer" id="chat-box" style="display:none;">
                <label for="chat-input" style="font-weight:600;">Send a follow-up</label>
                <textarea id="chat-input" placeholder="Ask a follow-up or continue the thread..."></textarea>
                <div class="chat-actions" style="align-items:center; gap:0.5rem;">
                    <button class="btn copy-md-btn" id="copy-md-btn-bottom" type="button">Continue on another platform</button>
                    <div class="chat-error" id="chat-error"></div>
                    <div class="chat-loading" id="chat-loading"></div>
                    <button class="btn btn-primary" id="chat-send" type="button">Send</button>
                </div>
                <div class="chat-waiting" id="chat-waiting">
                    <span class="dot"></span>
                    <span>Generating response…</span>
                </div>
            </div>

            <div class="share-bar">
                <p>Found this valuable? Share it with others.</p>
                <div class="share-actions">
                    <button class="btn btn-secondary copy-btn" id="copy-btn" onclick="copyLink()">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                        </svg>
                        Copy link
                    </button>
            <a href="#" id="twitter-share" target="_blank" class="btn btn-secondary">
                Share on X
            </a>
        </div>
    </div>
        </article>
    </div>

    <footer>
        <div class="footer-links">
            <a href="/privacy">Privacy</a>
            <a href="/terms">Terms</a>
            <a href="/api">API</a>
            <a href="https://github.com/warrofua/mnemolog" target="_blank">GitHub</a>
        </div>
        <span class="footer-note">Building continuity, together.</span>
    </footer>

    <div class="modal-backdrop" id="continue-modal">
        <div class="modal">
            <h3 class="title-font">Continue with <span class="nemo-mark">Nemo</span></h3>
            <p class="small-text">Pick a mode and optionally add a goal. We’ll create a continuation using Nemo.</p>
            <label for="continue-mode">Mode</label>
            <select id="continue-mode">
                <option value="continue">Continue (default)</option>
                <option value="outline">Outline it</option>
                <option value="code">Turn into code</option>
                <option value="critique">Critique it</option>
                <option value="simplify">Explain simply</option>
            </select>
            <label for="continue-goal">Optional goal</label>
            <textarea id="continue-goal" placeholder="What are you trying to do next?"></textarea>
            <div class="modal-actions">
                <button class="btn btn-secondary" id="continue-cancel" type="button">Cancel</button>
                <button class="btn btn-primary" id="continue-submit" type="button">Send</button>
            </div>
            <div class="small-text" id="continue-error" style="color: var(--warning); display:none;"></div>
        </div>
    </div>

    <script src="/assets/config.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="/assets/app.js"></script>
    <script src="/assets/render.js"></script>
    <script>
        function getConversationId() {
            const path = window.location.pathname;
            // Support /c/<id> (preferred) and /conversation/<id> so redirects still work
            const match = path.match(/\/(?:c|conversation)\/([a-f0-9-]{36})/i);
            if (match) return match[1];

            // Fallback: allow ?id=<uuid> for cases where host rewrites strip the path segment
            const idParam = new URLSearchParams(window.location.search).get('id');
            return idParam && /[a-f0-9-]{36}/i.test(idParam) ? idParam : null;
        }

        function formatDate(dateString) {
            return new Date(dateString).toLocaleDateString('en-US', { 
                month: 'long', day: 'numeric', year: 'numeric' 
            });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatContent(text) {
            let html = escapeHtml(text);
            // Apply heading detection early while newlines remain
            const renderHeading = window.mnemologRender?.applyHeadingStyle || ((x) => x);
            html = renderHeading(html);
            // Basic formatting
            html = html.replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>');
            html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
            html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/\*([^*]+)\*/g, '<em>$1</em>');
            // Preserve paragraph breaks and line breaks
            html = html.replace(/\n\n/g, '<br><br>');
            html = html.replace(/\n/g, '<br>');
            return html;
        }

        let currentConversationId = null;
        let currentMessages = [];
        let loadedConversation = null;
        let isGenerating = false;
        let chatBoxDisplay = '';
        let waitingEl = null;
        let loadingPlaceholder = null;
        let userScrollInterrupt = false;
        let lineageData = null;

        async function loadConversation() {
            const id = getConversationId();
            if (!id) { showError(); return; }

            try {
                // Ensure auth/session is loaded so private conversations owned by the user can be fetched
                await mnemolog.checkAuth();
                const { conversation } = await mnemolog.getConversation(id);
                if (!conversation) { showError(); return; }
                loadedConversation = conversation;
                currentConversationId = conversation.id;
                currentMessages = await loadLineageMessages(conversation);
            renderConversation(conversation);
            renderContinuations(conversation.children || []);
            await loadLineage(conversation.id);
            // If we arrived from a continuation redirect, start streaming the assistant
            if (window.location.hash === '#stream') {
                await maybeStartGeneration(conversation);
            }
            const copyBtn = document.getElementById('copy-md-btn');
            if (copyBtn) copyBtn.onclick = copyConversationMarkdown;
            const copyBtnBottom = document.getElementById('copy-md-btn-bottom');
            if (copyBtnBottom) copyBtnBottom.onclick = copyConversationMarkdown;
            const collapseBtn = document.getElementById('lineage-collapse');
            if (collapseBtn) {
                collapseBtn.onclick = () => {
                    const canvas = document.getElementById('lineage-canvas');
                    const icon = collapseBtn;
                    if (!canvas) return;
                    const hidden = canvas.style.display === 'none';
                    canvas.style.display = hidden ? 'block' : 'none';
                    icon.textContent = hidden ? 'Collapse' : 'Expand';
                };
            }
            setupTooltip();
        } catch (err) {
            console.error('Failed to load conversation:', err);
            showError();
        }
    }

        function showError() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('error').style.display = 'block';
        }

        // Fetch parent chain messages and merge with current
        async function loadLineageMessages(conversation) {
            const chain = [];
            let cursor = conversation;
            chain.unshift(cursor);
            if (conversation.intent_type !== 'fork') {
                while (cursor.parent_conversation_id) {
                    try {
                        const { conversation: parent } = await mnemolog.getConversation(cursor.parent_conversation_id);
                        if (!parent) break;
                        chain.unshift(parent);
                        cursor = parent;
                    } catch (e) {
                        break;
                    }
                }
            }
            const merged = [];
            chain.forEach((conv, idx) => {
                const msgs = conv.messages || [];
                msgs.forEach(m => merged.push(m));
                if (idx < chain.length - 1) {
                    const next = chain[idx + 1];
                    merged.push({ role: 'meta', content: 'Continued below', prompt: next?.user_goal || '' });
                }
            });
            return merged;
        }

        async function loadLineage(convoId) {
            const canvas = document.getElementById('lineage-canvas');
            const tooltip = document.getElementById('lineage-tooltip');
            if (!canvas) return;
            try {
                const resp = await fetch(`/api/conversations/${convoId}/lineage`);
                const data = await resp.json();
                if (!resp.ok) throw new Error(data.error || 'Failed to load lineage');
                lineageData = data;
                renderLineage(data);
                const refresh = document.getElementById('lineage-refresh');
                if (refresh) refresh.onclick = () => loadLineage(convoId);
            } catch (err) {
                console.error('Lineage load error', err);
                canvas.innerHTML = '<div style=\"padding:1rem;\">Lineage unavailable.</div>';
            }
        }

        function renderLineage(data) {
            const canvas = document.getElementById('lineage-canvas');
            const tooltip = document.getElementById('lineage-tooltip');
            if (!canvas || !data || !data.nodes) return;

            const nodes = data.nodes;
            const rootId = data.root_id;

            // Build children map (order by created_at to keep stable)
            const byId = new Map(nodes.map(n => [n.id, n]));
            const children = {};
            nodes.forEach(n => {
                if (n.parent_conversation_id) {
                    children[n.parent_conversation_id] = children[n.parent_conversation_id] || [];
                    children[n.parent_conversation_id].push(n);
                }
            });
            Object.values(children).forEach((arr) => {
                arr.sort((a, b) => (a.created_at || '').localeCompare(b.created_at || ''));
            });

            // Simple tidy tree: assign x by in-order traversal of leaves; parent x = mean of children
            let leafIndex = 0;
            let maxDepth = 0;
            const assignPos = (id, depth) => {
                const node = byId.get(id);
                if (!node) return;
                maxDepth = Math.max(maxDepth, depth);
                const kids = children[id] || [];
                if (!kids.length) {
                    node._layout = { depth, x: leafIndex++ };
                } else {
                    kids.forEach(k => assignPos(k.id, depth + 1));
                    const xs = kids.map(k => (byId.get(k.id)?._layout?.x || 0));
                    const avg = xs.reduce((a, b) => a + b, 0) / xs.length;
                    node._layout = { depth, x: avg };
                }
            };

            assignPos(rootId, 0);

            const totalLeaves = Math.max(leafIndex, 1);
            const widthPx = 900;
            const heightPx = Math.max(360, (maxDepth + 1) * 140);
            const padding = 40;
            const scaleX = totalLeaves > 1 ? (widthPx - padding * 2) / (totalLeaves - 1) : (widthPx - padding * 2);
            const scaleY = heightPx / Math.max(1, maxDepth + 1);

            // Center nodes horizontally if there are gaps
            const minX = Math.min(...nodes.map(n => n._layout?.x || 0));
            nodes.forEach(n => {
                if (n._layout) n._layout.x = n._layout.x - minX;
            });

            const svgParts = [];
            svgParts.push(`<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 ${widthPx} ${heightPx}\" preserveAspectRatio=\"xMidYMid meet\">`);

            // Edges
            nodes.forEach(n => {
                const kids = children[n.id] || [];
                kids.forEach(k => {
                    const from = n._layout;
                    const to = k._layout;
                    if (!from || !to) return;
                    const x1 = from.x * scaleX;
                    const y1 = (from.depth + 1) * scaleY - (scaleY * 0.6);
                    const x2 = to.x * scaleX;
                    const y2 = (to.depth + 1) * scaleY - (scaleY * 0.6);
                    const isFork = k.intent_type === 'fork';
                    svgParts.push(`<line x1=\"${x1}\" y1=\"${y1}\" x2=\"${x2}\" y2=\"${y2}\" stroke=\"currentColor\" stroke-width=\"1.4\" ${isFork ? 'stroke-dasharray=\"4 3\"' : ''} />`);
                });
            });

            // Nodes
            nodes.forEach(n => {
                const lay = n._layout;
                if (!lay) return;
                const x = lay.x * scaleX;
                const y = (lay.depth + 1) * scaleY - (scaleY * 0.6);
                const isRoot = n.id === rootId;
                const isFork = n.intent_type === 'fork';
                const color = isRoot ? '#b8860b' : isFork ? '#8a5adf' : '#2e7d4a';
                const isCurrent = n.id === currentConversationId;
                svgParts.push(`<g class=\"node\" data-id=\"${n.id}\" transform=\"translate(${x},${y})\" cursor=\"pointer\">`);
                const radius = isCurrent ? 18 : 16;
                const ring = isCurrent ? `<circle cx=\"0\" cy=\"0\" r=\"20\" fill=\"none\" stroke=\"#b8860b\" stroke-width=\"2.5\" />` : '';
                svgParts.push(ring);
                svgParts.push(`<circle cx=\"0\" cy=\"0\" r=\"${radius}\" fill=\"${color}\" opacity=\"0.15\" stroke=\"${color}\" stroke-width=\"1.5\" />`);
                svgParts.push(`<text x=\"0\" y=\"5\" text-anchor=\"middle\" fill=\"${color}\" font-size=\"10\" font-weight=\"600\">${isRoot ? 'Root' : isFork ? 'Fork' : 'Cont'}</text>`);
                svgParts.push(`</g>`);
            });

            svgParts.push(`</svg>`);
            canvas.innerHTML = svgParts.join('');

            // Re-attach tooltip/legend overlay
            const legendHtml = `
                <div class="lineage-legend">
                    <span><span class="legend-dot" style="background:#b8860b;"></span>Root / Current</span>
                    <span><span class="legend-dot" style="background:#2e7d4a;"></span>Continuation</span>
                    <span><span class="legend-dot" style="background:#8a5adf;"></span>Fork</span>
                </div>
            `;
            canvas.insertAdjacentHTML('beforeend', legendHtml);
            canvas.appendChild(tooltip);

            // Interactions
            const svg = canvas.querySelector('svg');
            if (!svg) return;
            svg.querySelectorAll('.node').forEach((g) => {
                const id = g.getAttribute('data-id');
                const node = byId.get(id);
                if (!node) return;
                g.addEventListener('mouseenter', () => {
                    if (!tooltip) return;
                    const rect = canvas.getBoundingClientRect();
                    const box = g.getBoundingClientRect();
                    tooltip.style.display = 'block';
                    tooltip.style.left = `${box.left - rect.left + 20}px`;
                    tooltip.style.top = `${box.top - rect.top - 10}px`;
                    const title = escapeHtml(node.title || 'Conversation');
                    const date = node.created_at ? formatDate(node.created_at) : '';
                    const views = node.view_count || 0;
                    const goal = escapeHtml(node.user_goal || '');
                    tooltip.innerHTML = `<div style=\"font-weight:600;\">${title}</div><div>${date} · ${views} views</div>${goal ? `<div>Goal: ${goal}</div>` : ''}`;
                });
                g.addEventListener('mouseleave', () => {
                    if (tooltip) tooltip.style.display = 'none';
                });
                g.addEventListener('click', () => {
                    window.location.href = `/c/${id}`;
                });
            });
        }


        function renderContinuations(children) {
            const panels = [
                {
                    panel: document.getElementById('continuations-panel-top'),
                    toggle: document.getElementById('continuations-toggle-top'),
                    countEl: document.getElementById('continuations-count-top'),
                    listEl: document.getElementById('continuations-list-top'),
                }
            ];

            panels.forEach(({ panel, toggle, countEl, listEl }) => {
                if (!panel || !toggle || !countEl || !listEl) return;

                if (!children || !children.length) {
                    panel.style.display = 'none';
                    return;
                }

                panel.style.display = 'block';
                countEl.textContent = `${children.length} ${children.length === 1 ? 'continuation' : 'continuations'}`;

                const previewCount = Math.min(3, children.length);
                const preview = children.slice(0, previewCount);
                const extra = children.slice(previewCount);

                const renderItem = (child, hidden = false) => {
                    const intent = child.intent_type ? `<span class="continuation-meta">${escapeHtml(child.intent_type)}</span>` : '';
                    const goal = child.user_goal ? `<span class="continuation-meta">${escapeHtml(child.user_goal)}</span>` : '';
                    const date = child.created_at ? formatDate(child.created_at) : '';
                    const views = typeof child.view_count === 'number' ? `<span class="continuation-meta">${child.view_count} views</span>` : '';
                    const hiddenClass = hidden ? ' hidden-continuation' : '';
                    return `
                        <a class="continuation-item${hiddenClass}" href="/c/${child.id}">
                            <div>
                                <h4>${escapeHtml(child.title || 'Continuation')}</h4>
                                <div class="continuation-meta">${date}${intent ? ' · ' + intent : ''}${goal ? ' · ' + goal : ''}${views ? ' · ' + views : ''}</div>
                            </div>
                        </a>
                    `;
                };

                listEl.innerHTML = [
                    ...preview.map(c => renderItem(c, false)),
                    ...extra.map(c => renderItem(c, true)),
                ].join('');

                let expanded = previewCount === children.length; // expand when only few
                const applyState = () => {
                    if (expanded) {
                        listEl.classList.add('show');
                        listEl.querySelectorAll('.hidden-continuation').forEach(el => el.style.display = 'block');
                        toggle.setAttribute('aria-expanded', 'true');
                    } else {
                        listEl.classList.remove('show');
                        listEl.querySelectorAll('.hidden-continuation').forEach(el => el.style.display = 'none');
                        toggle.setAttribute('aria-expanded', 'false');
                    }
                };
                applyState();
                toggle.onclick = () => {
                    expanded = !expanded;
                    applyState();
                };
            });
        }

        function renderConversation(data) {
            document.title = `${data.title} — Mnemolog`;
            const platformLookup = (window.mnemolog && window.mnemolog.platformNames) || {};
            document.getElementById('platform').textContent = platformLookup[data.platform] || data.platform;
            const modelEl = document.getElementById('model');
            const attribEl = document.getElementById('attrib');
            const lineageEl = document.getElementById('lineage-badge');
            const visitOriginalEl = document.getElementById('visit-original');
            const modelText = data.model_display_name || data.model_id || '';
            const attribText = data.attribution_confidence === 'verified'
                ? 'Verified'
                : data.attribution_confidence === 'inferred'
                    ? 'Inferred'
                    : data.attribution_confidence === 'claimed'
                        ? 'Claimed'
                        : '';
            const isContinuation = !!(data.parent_conversation_id || (data.root_conversation_id && data.root_conversation_id !== data.id));
            if (modelText) {
                modelEl.textContent = modelText;
                modelEl.style.display = 'inline-block';
            } else {
                modelEl.style.display = 'none';
            }
            if (attribText) {
                attribEl.textContent = attribText;
                attribEl.style.display = 'inline-block';
            } else {
                attribEl.style.display = 'none';
            }
            if (lineageEl) {
                lineageEl.style.display = isContinuation ? 'inline-block' : 'none';
            }
            if (visitOriginalEl) {
                if (data.root_conversation_id && data.root_conversation_id !== data.id) {
                    visitOriginalEl.style.display = 'inline-flex';
                    visitOriginalEl.href = `/c/${data.root_conversation_id}`;
                } else {
                    visitOriginalEl.style.display = 'none';
                }
            }
            document.getElementById('date').textContent = formatDate(data.created_at);
            document.getElementById('views').textContent = data.view_count || 0;
            document.getElementById('title').textContent = data.title;
            
            if (data.description) {
                document.getElementById('description').textContent = data.description;
            } else {
                document.getElementById('description').style.display = 'none';
            }

            const tagsContainer = document.getElementById('tags');
            if (data.tags && data.tags.length > 0) {
                tagsContainer.innerHTML = data.tags.map(tag => 
                    `<span class="tag">${escapeHtml(tag)}</span>`
                ).join('');
            } else {
                tagsContainer.style.display = 'none';
            }

            if (data.profiles && data.show_author) {
                document.getElementById('author-info').style.display = 'flex';
                document.getElementById('author-name').textContent = data.profiles.display_name || 'Anonymous';
                if (data.profiles.avatar_url) {
                    document.getElementById('author-avatar').src = data.profiles.avatar_url;
                }
            }

            // Owner edit link
            const editBtn = document.getElementById('edit-btn');
            if (window.mnemolog?.currentUser && window.mnemolog.currentUser.id === data.user_id) {
                editBtn.style.display = 'inline-flex';
                editBtn.href = `/share?edit=${data.id}`;
            } else {
                editBtn.style.display = 'none';
            }

            renderMessages();

            const url = window.location.href;
            document.getElementById('twitter-share').href = 
                `https://twitter.com/intent/tweet?url=${encodeURIComponent(url)}&text=${encodeURIComponent(data.title + ' — on Mnemolog')}`;

            document.getElementById('loading').style.display = 'none';
            document.getElementById('conversation').style.display = 'block';

            initBookmark(data.id);
            setupChat();
        }

        function renderMessages() {
            const container = document.getElementById('messages');
            container.innerHTML = (currentMessages || []).map((msg, idx) => {
                if (msg.loading) {
                    return `
                        <div class="message loading">
                            <div class="spinner-inline"></div>
                            <div class="message-content">Generating response…</div>
                        </div>
                    `;
                }
                if (msg.role === 'meta') {
                    return `
                        <div class="message meta">
                            <div class="meta-title">${escapeHtml(msg.content || 'Continued below')}</div>
                            ${msg.prompt ? `<div class="meta-prompt">Human prompt: ${escapeHtml(msg.prompt)}</div>` : ''}
                        </div>
                    `;
                }
                return `
                    <div class="message ${msg.role}">
                        <div class="message-role">${msg.role === 'human' ? 'Human' : 'AI'}</div>
                        <button class="fork-btn" data-idx="${idx}" type="button" title="Fork from here" onclick="forkFromMessage(${idx})">
                            <svg viewBox="0 0 32 32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M8 6v10c0 4 3 7 7 7h6"/>
                                <path d="M15 23v6"/>
                                <path d="M13 16h12"/>
                                <path d="M25 16l-3 3"/>
                                <path d="M25 16l-3 -3"/>
                            </svg>
                        </button>
                        <div class="message-content">${formatContent(msg.content)}</div>
                    </div>
                `;
            }).join('');
        }

        // Continue modal handlers
        function setupContinue() {
            const btn = document.getElementById('continue-btn');
            const modal = document.getElementById('continue-modal');
            const cancel = document.getElementById('continue-cancel');
            const submit = document.getElementById('continue-submit');
            const mode = document.getElementById('continue-mode');
            const goal = document.getElementById('continue-goal');
            const errEl = document.getElementById('continue-error');
            if (!btn || !modal || !cancel || !submit) return;

            const close = () => {
                modal.classList.remove('show');
                errEl.style.display = 'none';
                submit.disabled = false;
                submit.textContent = 'Run';
            };

            btn.onclick = () => {
                modal.classList.add('show');
            };
            cancel.onclick = close;
            modal.addEventListener('click', (e) => {
                if (e.target === modal) close();
            });

            submit.onclick = async () => {
                if (!currentConversationId) return;
                if (!window.mnemolog?.currentSession?.access_token) {
                    errEl.textContent = 'Please sign in to continue with Nemo.';
                    errEl.style.display = 'block';
                    return;
                }
                submit.disabled = true;
                submit.textContent = 'Sending...';
                errEl.style.display = 'none';
                try {
                    await streamContinuation(currentConversationId, mode.value, goal.value.trim() || undefined);
                    close();
                } catch (err) {
                    errEl.textContent = err?.message || 'Failed to continue';
                    errEl.style.display = 'block';
                    submit.disabled = false;
                    submit.textContent = 'Send';
                }
            };
        }

        function messageText(msg) {
            if (!msg) return '';
            if (typeof msg === 'string') return msg;
            if (msg.content && typeof msg.content === 'string') return msg.content;
            if (msg.content && msg.content.text) return msg.content.text;
            if (msg.content && msg.content.content) return msg.content.content;
            return '';
        }

        async function forkFromMessage(idx) {
            if (!currentConversationId) return;
            try {
                // Build a clean snapshot up to and including idx, human/assistant only
                const snapshot = (currentMessages || [])
                    .slice(0, idx + 1)
                    .filter(m => m.role === 'human' || m.role === 'assistant')
                    .map(m => ({
                        role: m.role,
                        content: messageText(m),
                    }));

                const resp = await fetch(`/api/conversations/${currentConversationId}/fork`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...(window.mnemolog?.currentSession?.access_token ? { 'Authorization': `Bearer ${window.mnemolog.currentSession.access_token}` } : {})
                    },
                    body: JSON.stringify({ fork_message_index: idx, messages_snapshot: snapshot, mode: 'fork' })
                });
                const data = await resp.json();
                if (!resp.ok) {
                    alert(data.error || 'Failed to fork conversation.');
                    return;
                }
                if (data.conversation_id) {
                    window.location.href = `/c/${data.conversation_id}#stream`;
                }
            } catch (err) {
                console.error('Fork failed', err);
                alert('Failed to fork conversation.');
            }
        }

        async function copyConversationMarkdown() {
            if (!loadedConversation || !currentMessages.length) {
                alert('Conversation not loaded yet.');
                return;
            }
            const lines = [];
            lines.push(`# ${loadedConversation.title || 'Conversation'}`);
            lines.push(`Source: https://mnemolog.com/c/${loadedConversation.id}`);
            if (loadedConversation.platform) lines.push(`Platform: ${loadedConversation.platform}`);
            lines.push('');
            currentMessages.forEach(m => {
                if (m.role === 'meta') return;
                const role = m.role === 'assistant' ? 'AI' : 'Human';
                const text = messageText(m);
                if (text) {
                    lines.push(`**${role}:**`);
                    lines.push(text);
                    lines.push('');
                }
            });
            const md = lines.join('\n').trim();
            try {
                await navigator.clipboard.writeText(md);
                alert('Conversation copied in Markdown. Paste into your preferred platform.');
            } catch (err) {
                console.error('Clipboard copy failed', err);
                alert('Could not copy to clipboard.');
            }
        }

        function copyLink() {
            navigator.clipboard.writeText(window.location.href);
            const btn = document.getElementById('copy-btn');
            btn.classList.add('copied');
            btn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg> Copied!`;
            setTimeout(() => {
                btn.classList.remove('copied');
                btn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg> Copy link`;
            }, 2000);
        }

        // Bookmark handling
        async function initBookmark(conversationId) {
            const btn = document.getElementById('bookmark-btn');
            const label = document.getElementById('bookmark-label');
            if (!btn || !window.mnemolog) return;

            const setState = (saved) => {
                btn.classList.toggle('saved', saved);
                if (label) label.textContent = saved ? 'Saved' : 'Save';
                btn.querySelector('svg')?.setAttribute('fill', saved ? 'currentColor' : 'none');
            };

            try {
                const saved = await mnemolog.isBookmarked(conversationId);
                setState(saved);
            } catch (e) {
                setState(false);
            }

            btn.onclick = async () => {
                try {
                    const saved = await mnemolog.toggleBookmark(conversationId);
                    // toggleBookmark returns list; check membership
                    const nowSaved = Array.isArray(saved) ? saved.includes(conversationId) : false;
                    setState(nowSaved);
                } catch (err) {
                    alert('Please sign in to save bookmarks.');
                }
            };
        }

        function setupChat() {
            const box = document.getElementById('chat-box');
            const input = document.getElementById('chat-input');
            const sendBtn = document.getElementById('chat-send');
            const errEl = document.getElementById('chat-error');
            const spinner = document.getElementById('chat-loading');
            if (!box || !input || !sendBtn) return;

            box.style.display = 'block';
            waitingEl = document.getElementById('chat-waiting');

            const send = async () => {
                const content = input.value.trim();
                if (!content || !currentConversationId) return;
                sendBtn.disabled = true;
                if (spinner) spinner.style.display = 'inline-block';
                if (waitingEl) waitingEl.style.display = 'flex';
                errEl.style.display = 'none';
                try {
                    await streamChatMessage(currentConversationId, content);
                    input.value = '';
                } catch (err) {
                    errEl.textContent = err?.message || 'Failed to send';
                    errEl.style.display = 'block';
                } finally {
                    sendBtn.disabled = false;
                    if (spinner) spinner.style.display = 'none';
                    if (waitingEl) waitingEl.style.display = 'none';
                }
            };

            sendBtn.onclick = async () => {
                await send();
            };

            input.addEventListener('keydown', async (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    await send();
                }
            });
        }

        // Streaming chat helper: consume SSE from worker -> Supabase function
        async function streamChatMessage(conversationId, content) {
            const headers = { 'Content-Type': 'application/json' };
            if (window.mnemolog?.currentSession?.access_token) {
                headers['Authorization'] = `Bearer ${window.mnemolog.currentSession.access_token}`;
            }
            toggleChatBox(false);
            if (waitingEl) waitingEl.style.display = 'flex';
            // Optimistically show the user message immediately
            const userMsg = { role: 'human', content };
            loadingPlaceholder = { role: 'assistant', loading: true };
            currentMessages = [...currentMessages, userMsg, loadingPlaceholder];
            renderMessages();
            scrollToBottom();
            const resp = await fetch(`/api/conversations/${conversationId}/messages`, {
                method: 'POST',
                headers,
                body: JSON.stringify({ content }),
            });
            if (!resp.ok || !resp.body) {
                const err = await safeJson(resp);
                toggleChatBox(true);
                if (waitingEl) waitingEl.style.display = 'none';
                // rollback user message
                currentMessages = currentMessages.filter(m => m !== userMsg && m !== loadingPlaceholder);
                loadingPlaceholder = null;
                renderMessages();
                throw new Error(err?.error || 'AI reply failed');
            }

            let targetId = conversationId;
            let assistantBuffer = '';
            let chunkCount = 0;
            const reader = resp.body.getReader();
            const decoder = new TextDecoder();
            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                const chunk = decoder.decode(value, { stream: true });
                const lines = chunk.split('\n').map(l => l.trim()).filter(Boolean);
                for (const line of lines) {
                    if (!line.startsWith('data:')) continue;
                    const dataStr = line.replace(/^data:\s*/, '');
                    if (dataStr === '[DONE]') {
                        if (assistantBuffer) {
                            const base = currentMessages.filter(m => !m.loading);
                            currentMessages = [...base, { role: 'assistant', content: assistantBuffer }];
                            renderMessages();
                        }
                        if (targetId && targetId !== currentConversationId) {
                            window.location.href = `/c/${targetId}`;
                        }
                        toggleChatBox(true);
                        if (waitingEl) waitingEl.style.display = 'none';
                        return;
                    }
                    try {
                        const obj = JSON.parse(dataStr);
                        if (obj.delta) {
                            assistantBuffer += obj.delta;
                            const base = (currentMessages || []).filter(m => !m.loading);
                            const tempMessages = [...base, { role: 'assistant', content: assistantBuffer }];
                            renderMessagesLive(tempMessages);
                            chunkCount++;
                            if (chunkCount % 3 === 0) {
                                scrollToBottom(true);
                            }
                        }
                        if (obj.conversation_id) {
                            targetId = obj.conversation_id;
                        }
                    } catch (e) {
                        // ignore parse errors
                    }
                }
            }
            toggleChatBox(true);
            if (waitingEl) waitingEl.style.display = 'none';
            loadingPlaceholder = null;
        }

        async function safeJson(resp) {
            try {
                return await resp.json();
            } catch {
                return null;
            }
        }

        function renderMessagesLive(messagesList) {
            const container = document.getElementById('messages');
            container.innerHTML = (messagesList || []).map(msg => {
                if (msg.loading) {
                    return `
                        <div class="message loading">
                            <div class="spinner-inline"></div>
                            <div class="message-content">Generating response…</div>
                        </div>
                    `;
                }
                if (msg.role === 'meta') {
                    return `
                        <div class="message meta">
                            <div class="meta-title">${escapeHtml(msg.content || 'Continued below')}</div>
                            ${msg.prompt ? `<div class="meta-prompt">Human prompt: ${escapeHtml(msg.prompt)}</div>` : ''}
                        </div>
                    `;
                }
                return `
                    <div class="message ${msg.role === 'meta' ? '' : msg.role}">
                        ${msg.role !== 'meta' ? `<div class="message-role">${msg.role === 'human' ? 'Human' : 'AI'}</div>` : ''}
                        <div class="message-content">${formatContent(msg.content)}</div>
                    </div>
                `;
            }).join('');
            scrollToBottom();
        }

        // Continuation kick-off: create child and redirect immediately
        async function streamContinuation(conversationId, mode, user_goal) {
            const headers = { 'Content-Type': 'application/json' };
            if (window.mnemolog?.currentSession?.access_token) {
                headers['Authorization'] = `Bearer ${window.mnemolog.currentSession.access_token}`;
            }
            const resp = await fetch(`/api/conversations/${conversationId}/continue-stream`, {
                method: 'POST',
                headers,
                body: JSON.stringify({ mode, user_goal }),
            });
            const data = await safeJson(resp);
            if (!resp.ok || !data?.conversation_id) {
                throw new Error(data?.error || 'Failed to start continuation');
            }
            window.location.href = `/c/${data.conversation_id}#stream`;
        }

        async function streamGeneration(conversationId, mode, user_goal, autoScroll = false) {
            if (isGenerating) return;
            isGenerating = true;
            toggleChatBox(false);
            if (waitingEl) waitingEl.style.display = 'flex';
            // show placeholder spinner if no assistant yet
            if (!loadingPlaceholder) {
                loadingPlaceholder = { role: 'assistant', loading: true };
                currentMessages = [...currentMessages, loadingPlaceholder];
                renderMessages();
                scrollToBottom(autoScroll);
            }
            const headers = { 'Content-Type': 'application/json' };
            if (window.mnemolog?.currentSession?.access_token) {
                headers['Authorization'] = `Bearer ${window.mnemolog.currentSession.access_token}`;
            }
            const resp = await fetch(`/api/conversations/${conversationId}/generate`, {
                method: 'POST',
                headers,
                body: JSON.stringify({ mode, user_goal }),
            });
            if (!resp.ok || !resp.body) {
                const err = await safeJson(resp);
                isGenerating = false;
                toggleChatBox(true);
                if (waitingEl) waitingEl.style.display = 'none';
                currentMessages = currentMessages.filter(m => m !== loadingPlaceholder);
                loadingPlaceholder = null;
                renderMessages();
                throw new Error(err?.error || 'AI reply failed');
            }
            let assistantBuffer = '';
            let chunkCount = 0;
            const reader = resp.body.getReader();
            const decoder = new TextDecoder();
            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                const chunk = decoder.decode(value, { stream: true });
                const lines = chunk.split('\n').map(l => l.trim()).filter(Boolean);
                for (const line of lines) {
                    if (!line.startsWith('data:')) continue;
                    const dataStr = line.replace(/^data:\s*/, '');
                    if (dataStr === '[DONE]') {
                        if (assistantBuffer) {
                            const base = currentMessages.filter(m => !m.loading);
                            currentMessages = [...base, { role: 'assistant', content: assistantBuffer }];
                            renderMessages();
                            scrollToBottom(autoScroll);
                        }
                        isGenerating = false;
                        toggleChatBox(true);
                        if (waitingEl) waitingEl.style.display = 'none';
                        return;
                    }
                    try {
                        const obj = JSON.parse(dataStr);
                        if (obj.delta) {
                            assistantBuffer += obj.delta;
                            const base = (currentMessages || []).filter(m => !m.loading);
                            const tempMessages = [...base, { role: 'assistant', content: assistantBuffer }];
                            renderMessagesLive(tempMessages);
                            chunkCount++;
                            if (autoScroll && chunkCount % 3 === 0) {
                                scrollToBottom(true);
                            }
                        }
                    } catch (e) {
                        // ignore
                    }
                }
            }
            isGenerating = false;
            toggleChatBox(true);
            if (waitingEl) waitingEl.style.display = 'none';
            loadingPlaceholder = null;
        }

        async function maybeStartGeneration(conversation) {
            // Only trigger if this conversation is a continuation and has no AI reply yet
            const hasAssistant = (conversation.messages || []).some(m => m.role === 'assistant');
            if (hasAssistant) return;
            scrollToBottom(true);
            try {
                await streamGeneration(conversation.id, conversation.intent_type || 'continue', conversation.user_goal, true);
                // remove hash to avoid duplicate retries
                history.replaceState(null, '', window.location.pathname);
            } catch (err) {
                console.error('Generation stream failed', err);
            }
        }

        function scrollToBottom(force = false) {
            if (userScrollInterrupt && !force) return;
            const container = document.getElementById('messages');
            if (!container) return;
            const target = container.getBoundingClientRect().top + window.scrollY + container.scrollHeight;
            const current = window.scrollY + window.innerHeight;
            const distance = Math.abs(target - current);
            const shouldScroll = force || distance < 600; // only smooth-scroll when near
            window.scrollTo({ top: target, behavior: shouldScroll ? 'smooth' : 'auto' });
        }

        // Track user scroll to disable auto-scroll until next force
        (function bindScrollInterrupt() {
            const onScroll = () => {
                userScrollInterrupt = true;
                clearTimeout(onScroll._t);
                onScroll._t = setTimeout(() => { userScrollInterrupt = false; }, 800);
            };
            window.addEventListener('scroll', onScroll, { passive: true });
        })();

        function setupTooltip() {
            const icon = document.getElementById('continue-tooltip');
            if (!icon) return;
            const toggle = (e) => {
                e.preventDefault();
                icon.classList.toggle('active');
            };
            icon.addEventListener('click', toggle);
            icon.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    toggle(e);
                }
            });
            document.addEventListener('click', (e) => {
                if (!icon.contains(e.target)) {
                    icon.classList.remove('active');
                }
            });
        }

        function toggleChatBox(show) {
            const box = document.getElementById('chat-box');
            if (!box) return;
            if (show) {
                box.style.display = chatBoxDisplay || 'block';
            } else {
                if (!chatBoxDisplay) chatBoxDisplay = box.style.display || 'block';
                box.style.display = 'none';
            }
        }

        loadConversation();
        setupContinue();
    </script>
</body>
</html>
